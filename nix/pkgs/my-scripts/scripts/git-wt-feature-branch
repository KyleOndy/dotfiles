#!/usr/bin/env bash
set -Eeo pipefail

# Jira ticket validation pattern (used in work mode)
readonly JIRA_PATTERN='^[A-Z]+-[0-9]+$'

# Get worktree root (find .bare directory)
# Allow command to fail gracefully (not in git repo is expected)
wt_root=$(git worktree list --porcelain 2>/dev/null | rg '^worktree.*\.bare$' | sed 's/\/\.bare$//' | sort -u | cut -d' ' -f2 || true)

if [[ -z "$wt_root" ]]; then
  echo "Error: Not in a worktree-based repository (no .bare found)" >&2
  echo "To set up a repository for this workflow, use: git wt-clone <url>" >&2
  exit 1
fi

# Auto-detect mode based on argument count
if [[ $# -eq 1 ]]; then
  # HOME MODE: Single argument
  # Supports both simple names and nested paths
  name="$1"
  base_branch="origin/main"

  feature_path="${wt_root}/${name}"
  branch_name="${name//\//-}"  # Convert slashes to hyphens

elif [[ $# -ge 2 ]]; then
  # WORK MODE: Ticket + name
  ticket="${1^^}"  # Uppercase ticket
  name="$2"
  base_branch=${3:-"origin/master"}

  # Validate Jira ticket format
  if [[ ! "$ticket" =~ $JIRA_PATTERN ]]; then
    echo "Error: Invalid ticket format '$ticket'. Expected format: PROJ-123" >&2
    exit 1
  fi

  feature_path="${wt_root}/${ticket}/${name}"
  branch_name="${ticket}-${name}"

else
  cat << 'EOF'
usage: git wt-feature-branch <name> [base]
       git wt-feature-branch <ticket> <name> [base]

Create a new git worktree with branch.

Home mode (1 argument):
  git wt-feature-branch add-starship
    → path: {repo}/add-starship/
    → branch: add-starship
    → base: origin/main

  git wt-feature-branch feature/something
    → path: {repo}/feature/something/
    → branch: feature-something
    → base: origin/main

Work mode (2+ arguments):
  git wt-feature-branch DEV-123 fix-the-thing
    → path: {repo}/DEV-123/fix-the-thing/
    → branch: DEV-123-fix-the-thing
    → base: origin/master (default)

  git wt-feature-branch DEV-123 fix-the-thing origin/develop
    → base: origin/develop (specified)

Ticket validation: Work mode requires valid Jira format (PROJ-123).
The script auto-detects mode based on argument count.
EOF
  exit 1
fi

# Create worktree
echo "Fetching latest from remote..."
git fetch

echo "Creating worktree..."
git worktree add --no-checkout -b "${branch_name}" "$feature_path" "$base_branch"

# Set up git-crypt for new worktree if configured
if git config --get filter.git-crypt.smudge &>/dev/null; then
  echo "Setting up git-crypt..."

  # Get the worktree's git directory
  worktree_git_dir=$(git -C "$feature_path" rev-parse --git-dir)

  # Create git-crypt keys directory
  mkdir -p "$worktree_git_dir/git-crypt/keys"

  # Decrypt the symmetric key from the repo using GPG
  # Try each .gpg file (in case multiple collaborators) and use the first successful decryption
  for gpg_key in .git-crypt/keys/default/0/*.gpg; do
    if [ -f "$gpg_key" ]; then
      if gpg --decrypt --quiet "$gpg_key" > "$worktree_git_dir/git-crypt/keys/default" 2>/dev/null; then
        break
      fi
    fi
  done
fi

# Checkout files after git-crypt is unlocked
echo "Checking out files..."
(cd "$feature_path" && git checkout "${branch_name}")

echo ""
echo "✓ Created worktree: ${feature_path}"
echo "✓ Branch: ${branch_name}"
echo "✓ Based on: ${base_branch}"
echo ""
echo "To start working:"
echo "  cd ${feature_path}"
