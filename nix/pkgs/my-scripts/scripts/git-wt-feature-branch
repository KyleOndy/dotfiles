#!/usr/bin/env bash
set -Eeo pipefail

# Jira ticket validation pattern (used in work mode)
readonly JIRA_PATTERN='^[A-Z]+-[0-9]+$'

# Get worktree root (find .bare directory)
# Allow command to fail gracefully (not in git repo is expected)
wt_root=$(git worktree list --porcelain 2>/dev/null | rg '^worktree.*\.bare$' | sed 's/\/\.bare$//' | sort -u | cut -d' ' -f2 || true)

if [[ -z "$wt_root" ]]; then
  echo "Error: Not in a worktree-based repository (no .bare found)" >&2
  echo "To set up a repository for this workflow, use: git wt-clone <url>" >&2
  exit 1
fi

# Detect the default branch for the remote
# Tries multiple methods in order of reliability:
# 1. Git's symbolic-ref (official default branch tracking)
# 2. Check if origin/main exists
# 3. Fall back to origin/master
get_default_branch() {
  # Try symbolic-ref first (most reliable)
  if default_branch=$(git symbolic-ref refs/remotes/origin/HEAD --short 2>/dev/null); then
    echo "$default_branch"
    return 0
  fi

  # Fallback: try main first, then master
  if git show-ref --verify --quiet refs/remotes/origin/main; then
    echo "origin/main"
    return 0
  fi

  if git show-ref --verify --quiet refs/remotes/origin/master; then
    echo "origin/master"
    return 0
  fi

  # Last resort: just use main (will fail later if it doesn't exist)
  echo "origin/main"
}

# Auto-detect mode based on argument count and flags
if [[ "$1" == "--existing" || "$1" == "-e" ]]; then
  # EXISTING BRANCH MODE: Checkout existing branch into worktree
  shift
  branch_name="$1"
  folder_prefix="$2"  # Optional namespace/prefix

  if [[ -z "$branch_name" ]]; then
    echo "Error: Branch name required when using --existing" >&2
    exit 1
  fi

  # Determine base branch using auto-detection
  base_branch=$(get_default_branch)

  # Build worktree path based on optional prefix
  if [[ -n "$folder_prefix" ]]; then
    feature_path="${wt_root}/${folder_prefix}/${branch_name}"
  else
    feature_path="${wt_root}/${branch_name}"
  fi

  # Validate that branch exists (check local first, then remote)
  echo "Checking if branch exists..."

  if git show-ref --verify --quiet "refs/heads/${branch_name}"; then
    # Local branch exists
    branch_source="local"
  elif git show-ref --verify --quiet "refs/remotes/origin/${branch_name}"; then
    # Remote branch exists
    branch_source="remote"
  else
    # Branch not found anywhere
    echo "Error: Branch '${branch_name}' not found locally or in remote" >&2
    echo "" >&2
    echo "Available local branches:" >&2
    git branch --list | sed 's/^[\* ]*/  /' | head -10 >&2
    echo "" >&2
    echo "Available remote branches:" >&2
    git branch -r | grep -v HEAD | sed 's/origin\//  /' | head -10 >&2
    exit 1
  fi

  # Set flag to indicate we're checking out existing branch
  checkout_existing=true

elif [[ $# -eq 1 ]]; then
  # HOME MODE: Single argument
  # Supports both simple names and nested paths
  name="$1"
  base_branch=$(get_default_branch)

  feature_path="${wt_root}/${name}"
  branch_name="${name//\//-}"  # Convert slashes to hyphens
  checkout_existing=false

elif [[ $# -ge 2 ]]; then
  # WORK MODE: Ticket + name
  ticket="${1^^}"  # Uppercase ticket
  name="$2"
  base_branch=${3:-$(get_default_branch)}

  # Validate Jira ticket format
  if [[ ! "$ticket" =~ $JIRA_PATTERN ]]; then
    echo "Error: Invalid ticket format '$ticket'. Expected format: PROJ-123" >&2
    exit 1
  fi

  feature_path="${wt_root}/${ticket}/${name}"
  branch_name="${ticket}-${name}"
  checkout_existing=false

else
  cat << 'EOF'
usage: git wt-feature-branch <name> [base]
       git wt-feature-branch <ticket> <name> [base]
       git wt-feature-branch --existing <branch> [prefix]

Create a new git worktree with branch, or checkout an existing branch.

Home mode (1 argument):
  git wt-feature-branch add-starship
    → path: {repo}/add-starship/
    → branch: add-starship (new)
    → base: auto-detected (origin/main or origin/master)

  git wt-feature-branch feature/something
    → path: {repo}/feature/something/
    → branch: feature-something (new)
    → base: auto-detected

Work mode (2+ arguments):
  git wt-feature-branch DEV-123 fix-the-thing
    → path: {repo}/DEV-123/fix-the-thing/
    → branch: DEV-123-fix-the-thing (new)
    → base: auto-detected (default)

  git wt-feature-branch DEV-123 fix-the-thing origin/develop
    → base: origin/develop (specified)

Existing branch mode (--existing/-e flag):
  git wt-feature-branch -e feature/cool-api
    → path: {repo}/feature/cool-api/
    → branch: feature/cool-api (existing)

  git wt-feature-branch -e bobs-feature PROJ-456
    → path: {repo}/PROJ-456/bobs-feature/
    → branch: bobs-feature (existing)
    → namespaced under: PROJ-456

  git wt-feature-branch -e fix-typo TRIVIAL
    → path: {repo}/TRIVIAL/fix-typo/
    → branch: fix-typo (existing)
    → namespaced under: TRIVIAL

Notes:
  - Default branch is auto-detected (tries: git symbolic-ref, origin/main, origin/master)
  - Work mode requires valid Jira format (PROJ-123)
  - Existing mode accepts any prefix (JIRA tickets, TRIVIAL, CHORE, etc.)
  - The script auto-detects mode based on flags and argument count
EOF
  exit 1
fi

# Create worktree
echo "Fetching latest from remote..."
git fetch

echo "Creating worktree..."
if [[ "$checkout_existing" == true ]]; then
  # Checkout existing branch (no -b flag)
  # For local branches, use the branch name directly
  # For remote branches, use the branch name and it will track the remote
  if [[ "$branch_source" == "local" ]]; then
    git worktree add --no-checkout "$feature_path" "$branch_name"
  else
    # Remote branch - checkout will create local tracking branch
    git worktree add --no-checkout "$feature_path" "$branch_name"
  fi
else
  # Create new branch
  git worktree add --no-checkout -b "${branch_name}" "$feature_path" "$base_branch"
fi

# Set up git-crypt for new worktree if configured
if git config --get filter.git-crypt.smudge &>/dev/null; then
  echo "Setting up git-crypt..."

  # Get the worktree's git directory
  worktree_git_dir=$(git -C "$feature_path" rev-parse --git-dir)

  # Create git-crypt keys directory
  mkdir -p "$worktree_git_dir/git-crypt/keys"

  # Decrypt the symmetric key from the repo using GPG
  # Try each .gpg file (in case multiple collaborators) and use the first successful decryption
  for gpg_key in .git-crypt/keys/default/0/*.gpg; do
    if [ -f "$gpg_key" ]; then
      if gpg --decrypt --quiet "$gpg_key" > "$worktree_git_dir/git-crypt/keys/default" 2>/dev/null; then
        break
      fi
    fi
  done
fi

# Checkout files after git-crypt is unlocked
echo "Checking out files..."
(cd "$feature_path" && git checkout "${branch_name}")

echo ""
echo "✓ Created worktree: ${feature_path}"
echo "✓ Branch: ${branch_name}"
if [[ "$checkout_existing" == true ]]; then
  echo "✓ Source: ${branch_source} branch"
else
  echo "✓ Based on: ${base_branch}"
fi
echo ""
echo "To start working:"
echo "  cd ${feature_path}"
