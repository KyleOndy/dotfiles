#!/usr/bin/env bash
set -euo pipefail

BUILD_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Comprehensive cleanup function that ALWAYS runs
cleanup() {
  local exit_code=$?

  # Always attempt cleanup if we have the required variables
  if [ -n "${INSTANCE_TYPE:-}" ] && [ -n "${AWS_ARCH:-}" ]; then
    echo ""
    echo "Cleanup triggered (exit code: $exit_code)"

    cd "$BUILD_DIR"

    # Kill any background processes
    jobs -p | xargs -r kill 2>/dev/null || true

    # Terraform destroy with retry
    local max_attempts=3
    local attempt=0

    while [ $attempt -lt $max_attempts ]; do
      if terraform destroy -auto-approve \
        -var="instance_type=$INSTANCE_TYPE" \
        -var="architecture=$AWS_ARCH" \
        2>&1 | tee /tmp/terraform-destroy.log; then
        echo "Instance terminated successfully"
        rm -f /tmp/terraform-destroy.log
        break
      else
        attempt=$((attempt + 1))
        echo "WARNING: Destroy attempt $attempt/$max_attempts failed"

        if [ $attempt -eq $max_attempts ]; then
          echo "ERROR: Terraform destroy failed after $max_attempts attempts"
          echo "EMERGENCY: Attempting direct AWS termination"

          if command -v aws &> /dev/null; then
            instance_id=$(terraform output -raw instance_id 2>/dev/null || echo "")
            if [ -n "$instance_id" ]; then
              echo "Terminating instance $instance_id directly..."
              aws ec2 terminate-instances --instance-ids "$instance_id" || true
            fi
          fi

          echo ""
          echo "ERROR: MANUAL INTERVENTION MAY BE REQUIRED"
          echo "   Directory: $BUILD_DIR"
          echo "   Manual cleanup command:"
          echo "     cd $BUILD_DIR && terraform destroy -auto-approve -var=\"instance_type=$INSTANCE_TYPE\" -var=\"architecture=$AWS_ARCH\""
          echo "   Or run: ./emergency-cleanup"
          echo ""
          echo "Terraform destroy log:"
          cat /tmp/terraform-destroy.log
        else
          sleep 5
        fi
      fi
    done
  fi

  if [ $exit_code -ne 0 ]; then
    echo "ERROR: Build failed with exit code $exit_code"
  fi

  exit $exit_code
}

# Register cleanup for ALL exit conditions
trap cleanup EXIT      # Normal exit
trap cleanup INT       # Ctrl+C
trap cleanup TERM      # Kill signal
trap cleanup ERR       # Error (with set -e)

# Validate arguments
if [ $# -lt 3 ]; then
  echo "Usage: $0 <instance-type> <architecture> <build-target>"
  echo ""
  echo "Arguments:"
  echo "  instance-type  : EC2 instance type (e.g., c6a.24xlarge, c7i.16xlarge)"
  echo "  architecture   : System architecture (x86_64-linux or aarch64-linux)"
  echo "  build-target   : Nix flake target to build"
  echo ""
  echo "Examples:"
  echo "  $0 c6a.24xlarge x86_64-linux .#nixosConfigurations.tiger.config.system.build.toplevel"
  echo "  $0 c7g.16xlarge aarch64-linux .#myPackage"
  exit 1
fi

INSTANCE_TYPE="$1"
ARCH="$2"
BUILD_TARGET="$3"

# Validate architecture
if [[ "$ARCH" != "x86_64-linux" ]] && [[ "$ARCH" != "aarch64-linux" ]]; then
  echo "ERROR: Architecture must be 'x86_64-linux' or 'aarch64-linux'"
  exit 1
fi

# Determine AWS architecture from Nix architecture
AWS_ARCH="amd64"
if [[ "$ARCH" == "aarch64-linux" ]]; then
  AWS_ARCH="arm64"
fi

echo "Provisioning $INSTANCE_TYPE builder for $ARCH..."
echo ""

cd "$BUILD_DIR"

# Provision instance
terraform init -upgrade
terraform apply -auto-approve \
  -var="instance_type=$INSTANCE_TYPE" \
  -var="architecture=$AWS_ARCH"

echo ""
echo "Manual cleanup command (if automatic cleanup fails):"
echo "  cd $BUILD_DIR && terraform destroy -auto-approve -var=\"instance_type=$INSTANCE_TYPE\" -var=\"architecture=$AWS_ARCH\""
echo ""

# Extract outputs
output_json="$(terraform output -json)"
host=$(echo "$output_json" | jq -r '.ec2_dns.value')
keypair_path=$(echo "$output_json" | jq -r '.keypair_file.value')
keypair_path=$(realpath "$keypair_path")  # Ensure absolute path for nix build

echo "Instance: $host"
echo "SSH Key: $keypair_path"

# Wait for SSH
echo "Waiting for SSH to be available..."
max_attempts=60
attempt=0
until ssh -i "$keypair_path" \
  -o ConnectTimeout=5 \
  -o StrictHostKeyChecking=no \
  -o UserKnownHostsFile=/dev/null \
  "root@$host" 'echo SSH ready' 2>/dev/null; do

  attempt=$((attempt + 1))
  if [ $attempt -ge $max_attempts ]; then
    echo "ERROR: Timeout waiting for SSH (${max_attempts} attempts)"
    exit 1
  fi
  sleep 5
done

echo "SSH connection established"

# Get CPU count from the instance itself (most accurate)
echo "Detecting CPU count..."
cpu_count=$(ssh -i "$keypair_path" \
  -o StrictHostKeyChecking=no \
  -o UserKnownHostsFile=/dev/null \
  "root@$host" 'nproc --all')

echo "Instance has $cpu_count vCPUs"

# Fetch host key for security
echo "Fetching host key..."
host_key=$(ssh -i "$keypair_path" \
  -o StrictHostKeyChecking=no \
  -o UserKnownHostsFile=/dev/null \
  "root@$host" 'base64 -w0 /etc/ssh/ssh_host_ed25519_key.pub')

# Determine GCC architecture features based on instance family
features="benchmark,big-parallel,kvm"
cpu_desc="Generic"

if [[ "$INSTANCE_TYPE" == c6a.* ]] || [[ "$INSTANCE_TYPE" == c7a.* ]]; then
  # AMD EPYC (Zen 3/4)
  features="${features},gccarch-znver3"
  cpu_desc="AMD EPYC (Zen 3/4)"
elif [[ "$INSTANCE_TYPE" == c6i.* ]] || [[ "$INSTANCE_TYPE" == c7i.* ]]; then
  # Intel Xeon (Ice Lake / Sapphire Rapids)
  features="${features},gccarch-skylake"
  cpu_desc="Intel Xeon (Ice Lake+)"
elif [[ "$INSTANCE_TYPE" == c6g.* ]] || [[ "$INSTANCE_TYPE" == c7g.* ]]; then
  # ARM Graviton
  cpu_desc="ARM Graviton"
fi

echo ""
echo "Build Configuration:"
echo "   Instance Type: $INSTANCE_TYPE ($cpu_desc)"
echo "   Architecture:  $ARCH"
echo "   vCPUs:         $cpu_count"
echo "   Max Jobs:      $cpu_count"
echo "   Features:      $features"
echo "   Target:        $BUILD_TARGET"
echo ""

# Build with remote builder
echo "Starting remote build..."
cd "$BUILD_DIR/../.."  # Back to dotfiles root

nix build "$BUILD_TARGET" \
  --max-jobs 0 \
  --builders "ssh://root@${host}?ssh-key=${keypair_path} ${ARCH} - ${cpu_count} 1 ${features} - ${host_key}" \
  --keep-going \
  --log-format bar-with-logs

echo ""
echo "Build complete!"
echo "Cleaning up builder to save costs..."

# Cleanup will happen automatically via trap
